package p1216;

public class a01폰카개념 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		/* 컬렉션
		 * 
		 * wrapper(기본 타입의 값을 객체로 다룰 수 있도록 함) 8가지
		 * 
		 * 패키지 개념과 필요성(한 폴더 안에선 동명의 파일은 존재불가)
		 * 경로가 다르면(패키지가 다르면) 상관없음
		 * 이름이 같아도 어느 경로(패키지)에 있느냐에 따라 내용이 다름
		 * 베데스다 게임 모드 깔때 생각해봐
		 * 
		 * 패키지와 모듈(폰카)
		 * 똑같은 math클래스라도, 내가 직접 만든 math클래스가 같은 경로에 있으면 math.PI는 java.lang의 PI값이 아닌 내가 만든 PI값을 출력한다
		 * 따라서 클래스명이 같을땐 패키지명까지 앞에 붙여야 구별해서 출력 가능   (println(패키지명.클래스명.PI))
		 * 다른 패키지에 있는 클래스 쓸때는 import 앞에 패키지명 붙인다   (import 패키지명.클래스명)
		 * java.lang 패키지만 import문 생략 가능
		 * 
		 * Object클래스
		 * 모든 클래스의 부모 클래스
		 * 모든 클래스에 강제 상속
		 * 
		 * Wrapper 클래스
		 * 기본타입의 값을 클래스화(객체로 만들기)
		 * (박싱, 언박싱) - wrapper의 일종
		 * ex) int를 Integer로 하여 String처럼 숫자 하나만 담당하도록 하는 방법
		 * 폰카에 전체 리스트 있음
		 * 
		 * 박싱, 언박싱
		 * 자동박싱과 자동언박싱
		 * 
		 * String 생성법은 2가지가 있다
		 * 1. 리터럴 방식 : String s = "hello" (테이블의 요소를 만든 후 바라보게함)
		 * 2. 힙 메모리 방식 : String객체 생성 = new String(); (객체마다 고유로 가짐)
		 * 
		 * 리터럴 테이블
		 * int a = 10;
		 * int b = 10;
		 * int c = a;
		 * 테이블에 10을 만들고, a가 10자리를 보게 한다.
		 * b의 경우 테이블에 10을 만들지 않고, a가 보는곳을 따라서 보게한다.
		 * c도 a가 보는곳을 보게 한다.
		 * 
		 * equals는 리터럴테이블, 힙메모리 구별 없이 값만 비교한다.
		 * 따라서 위에서 false가 나오던것도 equals로 하면 true가 나올 수 있다.
		 * 
		 * String 갹체는 수정 불가능
		 * concat
		 * 
		 * 문자열비교 compareTo
		 * 순서에 따라 0, 음수, 양수
		 * 
		 * 문자열 연결 방법
		 * 1. +연산자
		 * 2. concat
		 * 3. 기존 String 객체에 연결하지 않고 새로운 스트링 객체 리턴하기
		 * 
		 * 문자열 공백 제거(trim)
		 * 
		 * 스트링버퍼 : 실행하자마자 바뀐 값 할당하지 않아도 바로 본인에게 적용됨
		 */

	}

}
